import { createUser } from '../service/user.service';
import { UserInput } from '../models/user.model';
import { Pool } from 'pg'; // Import the actual pg library
jest.mock('pg');

describe('createUser', () => {
  const mockQuery = jest.fn();
  const mockConnect = jest.fn(() => ({
    query: mockQuery,
    release: jest.fn()
  }));
  
  beforeEach(() => {
    (Pool as  unknown as jest.Mock).mockClear(); // Clear any previous mocks
    mockQuery.mockClear(); // Clear mock query calls
    mockConnect.mockClear(); // Clear mock connect calls
  });
  // Tests that createUser successfully creates a user with valid input
  it('should create a user with valid input', async () => {
    
    // Arrange
    const userInput: UserInput = {
      name: 'John Doe',
      email: 'johndoe@example.com',
      password: 'password123',
    };
    const existingUserResult = {
      rows: []
    };
    const insertUserResult = {
      rows: [{ id: 1, ...userInput }]
    };
    mockQuery
      .mockResolvedValueOnce(existingUserResult) 
      .mockResolvedValueOnce(insertUserResult); 

    (Pool as unknown as jest.Mock).mockImplementation(() => ({
      connect: mockConnect,
      end: jest.fn() 
    }));
    jest.mock('bcrypt', () => ({
      hash: jest.fn().mockResolvedValue('hashedPassword')
    }));

    // Act
    const result = await createUser(userInput);

    // Assert
    expect(mockQuery).toHaveBeenCalledWith({
      text: 'SELECT * FROM users WHERE email = $1',
      values: ['johndoe@example.com']
    });
    expect(mockQuery).toHaveBeenCalledWith({
      text: expect.stringContaining('INSERT INTO users (name, email, password)'),
      values: ['John Doe', 'johndoe@example.com', 'hashedPassword']
    });
    
    expect(result).toEqual({ id: 1, ...userInput });
  });
});
